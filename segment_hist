#!/usr/bin/env python

#load required libraries
import os
import platform
import sys
from argparse import ArgumentParser, RawTextHelpFormatter
import itertools as it
from src import utility_functions, patch_selector


def build_parser():

    parser = ArgumentParser(formatter_class=RawTextHelpFormatter,
    description='''
    Segment_hist implements a semi-automatic pipeline to segment tissue slices from
    the background in high resolution whole-slde histopathological images and
    extracts patches of tissue segments from the full resolution image. 

    Whole slide histological images are very large in terms of size, making it
    difficult for computational pipelines to process them as single units, thus, 
    they have to be divided into patches. Moreover, a significant portion of each 
    image is background, which should be excluded from downstream analyses. 
    
    In order to efficiently segment tissue content from each image, $PROGNAME 
    utilizes a Canny edge detector and a graph-based segmentation method. A lower 
    resolution version of the image, extracted from the whole slide image file,
    is segmented. The background is defined as the segments that can be found at the
    borders or corners of the image (for more details check -b and -c arguments 
    documentation). Finally, patches are extracted from the full size image ,while
    the corresponding patches are checked in the segmented image. Patches with a 
    "tissue content" greater than a threshold value (-t) are selected.

    Moreover, segment_hist can function in test mode. This could assist the user in 
    setting the appropriate parameters for the pipeline. In test mode, segment_hist 
    will output the segmented version of the input image with scales indicating 
    the number of rows and columns. In that image the background should be separate 
    from the tissue pieces for the pipeline to work properly. 
    ''',
    epilog='''
    EXAMPLES
    --------
    
    Keep segmented image, save patches, produce a thumbnail with marked the
    selected patches, use a content threshold of 0.1 for patch selection.
    
    segment_hist -pfxt 0.1 input_image
    
    segment_hist -p -f -x -t 0.1 input_image

    Do not save patches, produce thumbnail, use different than the default values
    for k and m parameters.
    
    segment_hist -xk 10000 -m 1000 input_image

    Do not save patches, produce thumbnail, use a content threshold of 0.1 for
    patch selection, for background identification use bottom_left and top_right
    corners.
    
    segment_hist -xt 0.1 -b 0000 -c 0101 input_image
 
    Function in test mode, use different than the default values for k and m 
    parameters.
    
    segment_hist --test -k 1000 -m 1000 input_image

    
    REFERENCES
    ----------
    Felzenszwalb, P.F., & Huttenlocher, D.P. (2004). Efficient Graph-Based Image 
    Segmentation. International Journal of Computer Vision, 59, 167-181.
    ''')

    parser.add_argument('-s', '--sigma', type=float, default=0.5, help='''
    Parameter required by the segmentation algorithm. 
    Used to smooth the input image before segmenting it.
    Default value is 0.5.
    ''')
    
    parser.add_argument('-m', '--min', type=int, default=10000, help='''
    Parameter required by the segmentation algorithm. 
    Minimum segment size enforced by post-processing.
    Larger images require higher values.
    Default value is 10000.
    ''')
    
    parser.add_argument('-k', '--k-const', type=int, default=10000, help='''
    Parameter required by the segmentation algorithm.
    Value for the threshold function. The threshold function controls the 
    degree to which the difference between two segments must be greater than
    their internal differences in order for them not to be merged. Lower values
    result in finer segmentation. Larger images require higher values.
    Default value is 10000.
    ''')
    
    parser.add_argument('-l', '--level', type=int, default=1, help='''
    Integer indicating the level of the whole slide image file which will be 
    used to produce the segmentation. It should be greater than 0, beacause 
    level 0 is the full resolution image. Default value is 1, the second 
    largest version of the image.
    ''')
    
    parser.add_argument('-p', '--save-patches', action='store_true', 
                           default=False, help='''
    Save the produced patches of the full resolution image. By default, 
    segment_hist will not save them.                       
    ''')
    
    parser.add_argument('-t', '--content-threshold', type=float, default=0.5,
                          help='''
    Threshold parameter indicating the proportion of a patch content that 
    should not be covered by background in order to be selected. It should
    range between 0 and 1. Default value is 0.5.
                          ''', metavar='CONTENT_THRESHOLD', dest='thres')
    
    parser.add_argument('-d', '--patch-size', type=int, default=512, help='''
    Integer indicating the size of the produced patches. A value of D
    will produce patches of size D x D. Default value is 512.
    ''')
    
    parser.add_argument('-n', '--number-of-lines', type=int, default=100, 
                        help='''
    Integer indicating the number of lines from the borders or the corners of
    the segmented image that the algorithm should take into account to define
    background. Default value is 100.
    ''', metavar='NUMBER_OF_LINES', dest='lines')
    
    perms = list(set(it.permutations(['0','0','0','0','1','1','1','1'], 4)))
    combs = []
    for perm in perms: combs.append(''.join(perm))
    parser.add_argument('-b', '--borders', type=str, default='1111', help='''
    A four digit string. Each digit represents a border of the image in the 
    following order: left, bottom, right, top. If the digit is equal to 1 and
    not 0, then the corresponding border will be taken into account to define
    background. For instane, with -b 1010 the algorithm will look at the left
    and right borders of the segmented image, in a window of width defined by
    the -n argument, and every segment identified will be set as background. 
    If this argument is not equal to 0000, then -c should be 0000. 
    Default value is 1111.
    ''', choices=combs)
    
    parser.add_argument('-c', '--corners', type=str, default='0000', help='''
    A four digit string. Each digit represents a corner of the image in the 
    following order: top_left, bottom_left, bottom_right, top_right. If the 
    digit is equal to 1 and not 0, then the corresponding corner will be taken
    into account to define background. For instane, with -c 0101 the algorithm
    will look at the bottom_left and top_right corners of the segmented image,
    in a square window of size given by the -n argument, and every segment
    identified will be set as background. If this argument is not equal to 0000,
    then -b should be 0000. Default value is 0000.
    ''', choices=combs)
    
    parser.add_argument('-x', '--save-tilecrossed-image', action='store_true',
                       default=False, help='''
    Produce a thumbnail of the original image, in which the selected patches
    are marked with a blue X. By default, segment_hist will not do this.
    ''')
    
    parser.add_argument('-f', '--save-mask', action='store_true', default=False, 
                        help='''
    Keep the produced segmented image. By default, segment_hist will delete it.
    ''')

    parser.add_argument('-e', '--save-edges', action='store_true', default=False, 
                        help='''
    Keep the image produced by the Canny edge detector. 
    By default, segment_hist will delete it.
    ''')
    
    parser.add_argument('svs', type=str, help='''
    The whole slide image input file.
    ''', metavar='input_image')
    
    parser.add_argument('--test', help='''
    Function in test mode
    ''', action='store_true', default=False)
    
    return parser

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def check_compilation():
    if not os.path.isfile("src/Felzenszwalb_algorithm/segment"): 

        # If Windows, the user must compile the script manually, otherwise 
        # we attempt to compile it
        if platform.system() == "Windows":
            eprint("Please compile Felzenszwalb's algorithm before running this script. Exiting.")
            sys.exit(1)
        else:
            print("Compiling Felzenszwalb's algorithm...")
            try:
                subprocess.check_call(["make"], stdout=subprocess.PIPE, cwd="src/Felzenszwalb_algorithm/")
            except:
                eprint("Compilation of Felzenszwalb's algorithm failed. Please compile it before running this script. Exiting.")
                sys.exit(1)


if __name__ == "__main__":
    
    # Read arguments
    parser = build_parser()
    if len(sys.argv)==1:
        parser.print_help()
        sys.exit(1)
    args = parser.parse_args()

    # Check if the segmentation algorithm is compiled
    check_compilation()

    # Check for valid variables 
    ## Borders and Corners
    if (args.borders == '0000' and args.corners == '0000') or (args.borders != '0000' and args.corners != '0000'): eprint("Invalid borders and corners parameters! Exiting."); sys.exit(1)

    ##Content_threshold
    if args.thres > 1 or args.thres < 0: eprint("CONTENT_THRESHOLD should be a float number between 0 and 1! Exiting."); sys.exit(1) 

    sample_id = args.svs.split('.')[0]

    # Produce edge image
    print ('Producing edge image...')
    utility_functions.produce_edges(args.svs, "edges_" + sample_id  + ".jpg", args.level)

    # Convert to ppm
    print('Converting to ppm...')
    utility_functions.convert_to_ppm("edges_" + sample_id + ".jpg")

    # Run the segmentation algorithm
    print('Producing segmented image...')
    utility_functions.produce_segmented_image(sample_id)

    # delete image.ppm
    os.remove("ppmout.ppm")

    # test mode
    if (args.test):
        print('Producing test image...')
        utility_functions.produce_test_image(sample_id)
        os.remove("edges_" + sample_id + ".jpg")
        os.remove("segmented_" + sample_id + ".ppm")
        
        print('ALL DONE!')
        sys.exit(0)


    # Produce and select tiles
    patch_selector.run(sample_id, args.thres, args.patch_size, args.lines, 
                        args.borders, args.corners, args.save_tilecrossed_image, 
                        args.save_patches, args.svs)

    # Delete segmented and edge images
    if (not args.save_mask): os.remove("segmented_" + sample_id + ".ppm")
    if (not args.save_edges): os.remove("edges_" + sample_id + ".jpg")
    print('ALL DONE!')
